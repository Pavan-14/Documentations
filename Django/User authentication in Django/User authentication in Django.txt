=======================================================================================================================================================================
								   User authentication in Django
=======================================================================================================================================================================

Django comes with a user authentication system. It handles user accounts, groups, permissions and cookie-based user sessions.

The Django authentication system handles both authentication and authorization.

1. authentication verifies a user is who they claim to be

2. authorization determines what an authenticated user is allowed to do


The auth system consists of:

1. Users

2. Permissions: Binary (yes/no) flags designating whether a user may perform a certain task.

3. Groups: A generic way of applying labels and permissions to more than one user.

4. A configurable password hashing system

5. Forms and view tools for logging in users, or restricting content

6. A pluggable backend system


The authentication system in Django aims to be very generic and doesn’t provide some features commonly found in web authentication systems. Solutions for some of 
these common problems have been implemented in third-party packages:

	1. Password strength checking

	2. Throttling of login attempts
	
	3. Authentication against third-parties (OAuth, for example)

	4. Object-level permissions



Installation
-------------

Authentication support is bundled as a Django contrib module in django.contrib.auth.

By default, the required configuration is already included in the settings.py generated by django-admin startproject, these consist of two items listed in 
your INSTALLED_APPS setting.

1. 'django.contrib.auth' contains the core of the authentication framework, and its default models.

2. 'django.contrib.contenttypes' is the Django content type system, which allows permissions to be associated with models you create.


and these items in your MIDDLEWARE setting.

1. SessionMiddleware manages sessions across requests.

2. AuthenticationMiddleware associates users with requests using sessions.

With these settings in place, running the command manage.py migrate creates the necessary database tables for auth related models and permissions for any models 
defined in your installed apps.




Using the Django authentication system
---------------------------------------

1. User objects
----------------

User objects are the core of the authentication system. They typically represent the people interacting with your site and are used to enable things like restricting 
access, registering user profiles, associating content with creators etc.

Only one class of user exists in Django’s authentication framework, This means 'superusers' or 'admin' and 'staff' users are just user objects with special attributes 
set, not different classes of user objects. They both users are same class(User) objects.

User model
-----------
from django.contrib.auth.models import User

User model Fields
------------------

1. username     ===>    # Required. 150 characters or fewer. Usernames may contain alphanumeric, _, @, +, . and - characters.

2. first_name   ===>    # Optional (blank=True). 30 characters or fewer.

3. last_name    ===>    # Optional (blank=True). 150 characters or fewer.

4. email        ===>    # Optional (blank=True). Email address.

5. password     ===>    # Required. A hash of, and metadata about, the password. (Django doesn’t store the raw password.)

6. groups       ===>    # Many-to-many relationship to Group

7. user_permissions ===> # Many-to-many relationship to Permission

8. is_staff     ===>    # Boolean. Designates whether the user can log into the admin site.

9. is_active    ===>    # Boolean. Designates whether this user account should be considered active. We recommend that you set this flag to False instead of deleting accounts; that way, if your applications have any foreign keys to users, the foreign keys won’t break.

10. is_superuser ===>   # Boolean. Designates that this user has all permissions without explicitly assigning them

11. last_login   ===>   # A datetime of the user’s last login.

12. date_joined  ===>   # A datetime designating when the account was created. this set to the current date/time by default when the account is created.


User model attributes
----------------------

1. is_authenticated   ===>   # Tells that user is authenticated user or not.( True if user authenticated otherwise False )

2. is_anonymous       ===>   # Tells that user is anonymous user or not. ( True if user is annonymous user otherwise False )


User model Methods
-------------------

1. get_username()

	Returns the username for the user.
	Since the User model can be swapped out, you should use this method instead of referencing the username attribute directly

2. get_full_name()

	Returns the first_name plus the last_name, with a space in between.

3. get_short_name()

	Returns the first_name.

4. set_password(raw_password)
	
	Sets the user’s password to the given raw string, taking care of the password hashing.
	When the raw_password is None, the password will be set to an unusable password.

5. check_password(raw_password)

	Returns True if the given raw string is the correct password for the user. (This takes care of the password hashing in making the comparison.)

6. set_unusable_password()

	Marks the user as having no password set. This is not the same as having a blank string for a password. check_password() for this user will never return True.
	

7. has_usable_password()

	Returns True if the user set a passowrd. if we marked user as no password set using set_unusable_password() then it will return False.

8. get_user_permissions(obj=None)

	Returns a set of permission strings that the user has directly.
	If obj is passed in, only returns the user permissions for this specific object.


	New in Django 3.0.

9. get_group_permissions(obj=None)

	Returns a set of permission strings that the user has, through their groups.
	If obj is passed in, only returns the group permissions for this specific object.

10. get_all_permissions(obj=None)

	Returns a set of permission strings that the user has, both through group and user permissions.
	If obj is passed in, only returns the permissions for this specific object.

11. has_perm(perm, obj=None)

	Returns True if the user has the specified permission, where perm is in the format "<app label>.<permission codename>".
	If the user is inactive, this method will always return False. For an active superuser, this method will always return True.
	If obj is passed in, this method won’t check for a permission for the model, but for this specific object.

12. has_perms(perm_list, obj=None)

	Returns True if the user has each of the specified permissions, where each perm is in the format "<app label>.<permission codename>".
	If the user is inactive, this method will always return False. For an active superuser, this method will always return True.
	If obj is passed in, this method won’t check for permissions for the model, but for the specific object.

13. has_module_perms(package_name)

	Returns True if the user has any permissions in the given package (the Django app label).
	If the user is inactive, this method will always return False. For an active superuser, this method will always return True.

14. email_user(subject, message, from_email=None, **kwargs)

	Sends an email to the user. If from_email is None, Django uses the DEFAULT_FROM_EMAIL. Any **kwargs are passed to the underlying send_mail() call.



User model's Manager methods
-----------------------------

1. create_user(username, email=None, password=None, **extra_fields)

	Creates, saves and returns a User.
	
	The username and password are set as given. The domain portion of email is automatically converted to lowercase, and the returned User object will have 
	is_active set to True.

	If no password is provided, set_unusable_password() will be called.

	The extra_fields keyword arguments are passed through to the User’s __init__ method


2. create_superuser(username, email=None, password=None, **extra_fields)

	Same as create_user(), but sets is_staff and is_superuser to True.
	
	Changed in Django 3.0:
		The email and password parameters were made optional.


3. with_perm(perm, is_active=True, include_superusers=True, backend=None, obj=None)
	
	New in Django 3.0.

	Returns users that have the given permission perm either in the "<app label>.<permission codename>" format or as a Permission instance. Returns an empty 
	queryset if no users who have the perm found.

	If is_active is True (default), returns only active users, or if False, returns only inactive users. Use None to return all users irrespective of active state.

	If include_superusers is True (default), the result will include superusers.

	If backend is passed in and it’s defined in AUTHENTICATION_BACKENDS, then this method will use it. Otherwise, it will use the backend in 
	AUTHENTICATION_BACKENDS, if there is only one, or raise an exception.




AnonymousUser object
---------------------

"django.contrib.auth.models.AnonymousUser" is a class that implements the "django.contrib.auth.models.User interface" with these differences:

1. id is always None.

2. username is always the empty string.

3. get_username() always returns the empty string.

4. is_anonymous is True instead of False.

5. is_authenticated is False instead of True.

6. is_staff and is_superuser are always False.

7. is_active is always False.

8. groups and user_permissions are always empty.

9. set_password(), check_password(), save() and delete() raise NotImplementedError.



Permission model
-----------------

Permission model objects have the following fields:

1. name           ===>   # Required. 255 characters or fewer. Example: 'Can vote'.

2. content_type   ===>   # Required. A reference to the django_content_type database table, which contains a record for each installed model.

3. codename       ===>   # Required. 100 characters or fewer. Example: 'can_vote'.


Group model
------------

Group model objects have the following fields:

1. name		===>	 # Required. 150 characters or fewer. Any characters are permitted. Example: 'Awesome Users'.

2. permissions	===> 	 # Many-to-many field to Permission.


Ex:
----

group.permissions.set([permission_list])
group.permissions.add(permission, permission, ...)
group.permissions.remove(permission, permission, ...)
group.permissions.clear()




Login and logout signals
-------------------------

The auth framework uses the following signals that can be used for notification when a user logs in or out.

1. user_logged_in()    ===>   # Sent when a user logs in successfully.

	Arguments sent with this signal:

		sender   ===>   # The class of the user that just logged in.
	
		request  ===>   # The current HttpRequest instance.
		
		user     ===>   # The user instance that just logged in. 


2. user_logged_out()    ===>   # Sent when the logout method is called.

	sender   ===>    # As above: the class of the user that just logged out or None if the user was not authenticated.

	request  ===>    # The current HttpRequest instance.

	user     ===>    # The user instance that just logged out or None if the user was not authenticated.


3. user_login_failed()    ===>    # Sent when the user failed to login successfully

	sender   ===>    # The name of the module used for authentication.

	credentials ===> # A dictionary of keyword arguments containing the user credentials that were passed to authenticate() or your own custom authentication backend. Credentials matching a set of ‘sensitive’ patterns, (including password) will not be sent in the clear as part of the signal.

	request   ===>   # The HttpRequest object, if one was provided to authenticate().



NOTE:
------

FOR CREATING CUSTOM USER MODEL REFER THIS LINK   "https://docs.djangoproject.com/en/3.0/topics/auth/customizing/#auth-custom-user"




=====================
Practical Examples
=====================

Creating user
--------------

from django.contrib.auth.models import User

user = User.objects.create_user('john', 'lennon@thebeatles.com', 'johnpassword')

user.last_name = 'xyz'

user.save()


Creating user by providing default UserRegistrationForm
--------------------------------------------------------

Django provides a default registration form for the Default User model


views.py
---------

from django.contrib.auth.forms import UserCreationForm

def signup(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_bound:
            if form.is_valid():
                form.save()
                form = UserCreationForm()
                
                messages.success(request, 'User created successfully')
    else:
        form  = UserCreationForm()
        
    return render(request, 'signup.html', {'form':form})


signup.html
-------------

{% extends 'base.html' %}

{% block content %}
<div class="container">
    <form action="" method="POST">
        {% csrf_token %}
        {{form.as_p}}

        <button type="submit" class="btn btn-primary">Create</button>
    </form>   

</div>

{% endblock %}


This default UserCreationForm has 3 input fields by default

1. username
2. password
3. passowrd conform

If you want to use other fields of default user model then create a form class by extending UserCreationForm

forms.py
---------
from django.contrib.auth.models import User
from django.contrib.auth.forms import UserCreationForm

class userregistrationform(UserCreationForm):
    class Meta:
        model = User
        fields = ['username', 'email', 'password1', 'password2']
        widgets = {
            'username': forms.TextInput(attrs={'class':'form-control'}),
            'email': forms.EmailInput(attrs={'class':'form-control'}),
            'password1': forms.PasswordInput(attrs={'class':'form-control'}),
            'password2': forms.PasswordInput(attrs={'class':'form-control'}),
        }


from.save() will call the create_user() method with fields in the form and create a user account.

there is a small problem in above implimentaion of customuserregistration for by extending the default UserRegistrationForm.
in the above from class username and email are model fields they are taking from user model, but password1 and password2 are UserRegistrationForm fields they are 
taking from form not model so, if we apply widget attributes on these fields will have no effect and use.

so to overcome this we need to create a CustomUserRegistrationForm from the scratch

Ex:
----

class CustomUserRegistrationForm(forms.ModelForm):
   
    """
    A form that creates a user, with no privileges, from the given username and
    password. This custom registration form is implimented by copying the Default 
    UserRegistrationForm logic. Because applying class attribute in the widgets on password
    fields of subclass extended the UserRegistrationForm like above commented from is 
    not working.
    """
    
    error_messages = {
        'password_mismatch': ('The two passcode fields didn’t match.'),
    }
    
    password1 = forms.CharField(
        label=("Passcode"),
        strip=False,
        widget=forms.PasswordInput(attrs={'class':'form-control', 'autocomplete': 'new-password'}),
        help_text=password_validation.password_validators_help_text_html(),
    )
    
    password2 = forms.CharField(
        label=("Passcode confirmation"),
        widget=forms.PasswordInput(attrs={'class':'form-control', 'autocomplete': 'new-password'}),
        strip=False,
        help_text=("Enter the same password as before, for verification."),
    )
    
    class Meta:
        model = User
        fields = ['username', 'email', ]
        
        widgets = {
            'username': forms.TextInput(attrs={'class':'form-control', 'autofocus':True}),
            'email': forms.EmailInput(attrs={'class':'form-control'}),
        }
        
        labels = {
            'email':('Email'),
        }
        
    def clean_password2(self):
        password1 = self.cleaned_data.get("password1")
        password2 = self.cleaned_data.get("password2")
        if password1 and password2 and password1 != password2:
            raise forms.ValidationError(
                self.error_messages['password_mismatch'],
                code='password_mismatch',
            )
        return password2
    
    def _post_clean(self):
        super()._post_clean()
        # Validate the password after self.instance is updated with form data
        # by super().
        password = self.cleaned_data.get('password2')
        if password:
            try:
                password_validation.validate_password(password, self.instance)
            except forms.ValidationError as error:
                self.add_error('password2', error)
                
    
    def clean_email(self):
        '''
        This function is used to clean the email field of registrationform.
        it check wether email is alreday taken or not.
        '''
        email = self.cleaned_data.get('email')
        
        if User.objects.filter(email = email).exists():
            self.add_error('email', 'Email already taken!')
                
                
    def save(self, commit=True):
        user = super().save(commit=False)
        user.set_password(self.cleaned_data["password1"])
        if commit:
            user.save()
        return user



Creating superusers
--------------------
Create superusers using the createsuperuser command.

python manage.py createsuperuser

it will prompt for the username, email and password values and creates the superuser. it will set is_active=True, is_staff=True, is_superuser=True



Changing passwords
-------------------

Django does not store raw (clear text) passwords on the user model, but only a hash (see documentation of how passwords are managed for full details). Because of 
this, do not attempt to manipulate the password attribute of the user directly. This is why a helper function is used when creating a user.

To change a user’s password, you have several options:

1. manage.py changepassword *username* offers a method of changing a user’s password from the command line. It prompts you to change the password of a given user 
which you must enter twice. If they both match, the new password will be changed immediately. If you do not supply a user, the command will attempt to change the 
password whose username matches the current system user.

(Django2.0.7_Py3.6.5) C:\Users\Vissu\Desktop\Web-Dev\Django2.0.7_Py3.6.5\Dlearning>python manage.py changepassword abc
Changing password for user 'abc'
Password:
Password (again):
Password changed successfully for user 'abc'


2. You can also change a password programmatically, using set_password().


from django.contrib.auth.models import User

u = User.objects.get(username='abc')
u.set_password('new password')
u.save()



Authenticating users
---------------------

1. authenticate(request=None, **credentials)

	Use authenticate() to verify a set of credentials. It takes credentials as keyword arguments, username and password for the default case, checks them against 
	each authentication backend, and returns a User object if the credentials are valid for a backend. If the credentials aren’t valid for any backend or if a 
	backend raises PermissionDenied, it returns None.


	Ex:
	----
	from django.contrib.auth import authenticate
	
	user = authenticate(username='john', password='secret')
	
	if user is not None:
    	    # A backend authenticated the credentials

	else:
    	    # No backend authenticated the credentials

	
	request is an optional HttpRequest which is passed on the authenticate() method of the authentication backends.



Authentication in Web requests
-------------------------------

Django uses sessions and middleware to hook the authentication system into request objects.

These provide a request.user attribute on every request which represents the current user. If the current user has not logged in, this attribute will be set to an 
instance of AnonymousUser, otherwise it will be an instance of User.

You can tell them apart with is_authenticated, like so.

if request.user.is_authenticated:
    # Do something for authenticated users.
    ...
else:
    # Do something for anonymous users.
    ...




How to log a user in
---------------------

If you have an authenticated user you want to attach to the current session - this is done with a login() function.


1. login(request, user, backend=None)
	
	To log a user in, from a view, use login(). 
	
	It takes an HttpRequest object and a User object. 
	
	login() saves the user’s ID in the session, using Django’s session framework.


	NOTE:
	------
	Note that any data set during the anonymous session is retained in the session after a user logs in.


Selecting the authentication backend
-------------------------------------
When a user logs in, the user’s ID and the backend that was used for authentication are saved in the user’s session.

This allows the same authentication backend to fetch the user’s details on a future request.
 
The authentication backend to save in the session is selected as follows:

	1. Use the value of the optional backend argument, if provided.

	2. Use the value of the user.backend attribute, if present. This allows pairing authenticate() and login(): 
	   authenticate() sets the user.backend attribute on the user object it returns.

	3. Use the backend in AUTHENTICATION_BACKENDS, if there is only one.
	
	4. Otherwise, raise an exception.



LogIn a user using default user AuthenticationForm
---------------------------------------------------
Django provides default user AuthenticationForm 
login user using default AuthenticationForm

views.py
---------
from django.contrib.auth.forms import AuthenticationForm

def signin(request):
       
    #This is implimented by using default AuthenticationForm
       
    if request.method == 'POST':
        form = AuthenticationForm(request = request, data = request.POST)
        
        if form.is_bound:
            if form.is_valid():
                username = form.cleaned_data['username']
                password = form.cleaned_data.get('password')
                
                user = authenticate(request, username=username, password=password)
        
                if user is not None:
                    login(request, user)
                    return redirect('books-list')
            
    else:
        form = AuthenticationForm()
        
    return render(request, 'login.html', {'form':form})


login.html
-----------
{% extends 'base.html' %}

{% block content %}

<div class="container">

    <div class="col-lg-4">

    </div>
    
    <div class="col-lg-4 bg-success">

        <div class="container-fluid">
            <h1><p class="text-center">User LogIn Form</p></h1>
        </div>

        {% if messages %}

        {% for message in messages %}
        <div class="alert alert-success">
            <button type="button" class="close" data-dismiss="alert">&times;</button>
            {{ message }}
        </div>

        {% endfor %}
        
        {% endif %}

        {% if form.non_field_errors %}
        {% for error in form.non_field_errors %}
            <p class="text-danger">{{ error }}</p>
        {% endfor %}
        {% endif %}
        

        <form action="" method="POST">
            {% csrf_token %}
            <input type="hidden" name="next" value="{{ request.GET.next }}" />
            
            {% for field in form %}

            {% if field.errors %}

            <div class="form-group">
                <label for="id_{{field.label}}" class="control-label">{{ field.label }}</label>

                <div class="control">
                    {{ field }}
                    <ul class="errorlist">
                        {% for error in field.errors %}
                        <li><strong style="color: red;">{{ error }}</strong></li>
                    {% endfor %}
                    </ul>
                </div>
            </div>

            {% else %}

            <div class="form-group">
                <label for="id_{{field.label}}" class="control-label">{{field.label}}</label>

                <div class="control">   
                    {{field}}
                </div>

            </div>

            {% endif %}

            {% endfor %}
            
            <div class="container-fluid">
                <br><button type="submit" class="btn btn-primary">LogIn</button>
            </div><br>

            <div class="container-fluid">
                New to Bookstore? <a href="{% url 'signup-path'%}">Sign-up</a>
            </div><br>
            
        </form>

    </div>

    <div class="col-lg-4">

    </div>
       
</div>

{% endblock %}



LogIn a user using custom user Loginform
-----------------------------------------
Instead of using default AuthenticationForm we can create own login form and use that to log the user in

forms.py
---------
class Loginform(forms.Form):
    username = forms.CharField(
        max_length = 30, 
        label = 'Username', 
        widget = forms.TextInput(attrs={'class':'form-control', 'autofocus':True})
    )
    passcode = forms.CharField(
        label = 'Passcode',
        strip = False,
        widget = forms.PasswordInput(attrs={'class':'form-control'})
    )
    

views.py
---------

def signin(request):
    # import pdb; pdb.set_trace()
    if request.user.is_authenticated:
        return redirect('home-page')
    
    else:
        if request.method == 'POST':
            form = forms.Loginform(request.POST)
        
            username = request.POST['username']
            passcode = request.POST.get('passcode')
        
            if username and passcode:
            
                if not User.objects.filter(username=username).exists():    # if we use get instead of filter it will give DoesNotExists exception if user not there in the database.
                    form.add_error('username', 'There is no user with the name '+username)
                
                else:
                    user = User.objects.get(username=username)
                
                    if not check_password(passcode, user.password):
                        form.add_error('passcode', 'Invalid Passcode!')
                        
                    else:
                        user = authenticate(request=request, username=username, password=passcode)
                    
                        if user is not None:
                            login(request, user)
                            if request.POST.get('next'):
                                return redirect(request.POST.get('next'))    # 'next' is for redirecting to @login_required() specified url, if no next then redirects to 'books-list' after user logedin successfully.
                                # or
                                # return HttpResponseRedirect(request.POST.get('next'),'/accounts/loggedin')
                            else:
                                return redirect('home-page')
        else:
            form = forms.Loginform()
        
        return render(request, 'login.html', {'form':form})



login.html
-----------

same as used in the above approach(LogIn a user using default user AuthenticationForm).






Limiting access to logged-in users
-----------------------------------

Limiting access to logged-in users has two ways:
	
	1. raw way

	2. login_required decorator


raw way
--------
The raw way to limit access to pages is to check request.user.is_authenticated and either redirect to a login page:

from django.conf import settings
from django.shortcuts import redirect

def my_view(request):
    if not request.user.is_authenticated:
        return redirect('%s?next=%s' % (settings.LOGIN_URL, request.path))     # We must define a variable " LOGIN_URL = 'login path' " in settings.py file.
	
    else:
	process the view


NOTE:
------
Instead of settings.LOGIN_URL we can give " reverse('signin url name') ".

next parameter is used to redirect to the requested page instead of home page after user logedin successfully. 

We have to add this line " return redirect(request.POST.get('next','books-list')) " to our loginview after login the user using login() method

def signin(request):
    some logic
    user = authenticate(request=request, username=username, password=passcode)
                    
    if user is not None:
        login(request, user)
        return redirect(request.POST.get('next','books-list'))


Add this line " <input type="hidden" name="next" value="{{ request.GET.next }}" /> " to login.html file after the csrf_token inside the form.

<form action="" method="POST">
 {% csrf_token %}
 <input type="hidden" name="next" value="{{ request.GET.next }}" />
 SOME LOGIC
</form>
            


Ex:
----
def addauthor(request):
    if request.user.is_authenticated:
        if request.method == 'POST':
            form = forms.authorform(request.POST)
            
            if form.is_bound:                              # tell you whether the form has data bound to it or not
                
                if form.is_valid():                         
                    name = form.cleaned_data['authname']
                    email = form.cleaned_data['email']
                    age = form.cleaned_data['age']
            
                    author = Author.objects.create(name = name, email=email, age=age)  # to create and save obj in single step use create() method

                    return HttpResponseRedirect(reverse('success'))
        else:
            form = forms.authorform()
            
        return render(request, 'addauthor.html', {'form':form})
    
    else:
        return redirect('%s?next=%s' % (reverse('signin-path'), request.path))




login_required decorator
-------------------------
login_required(redirect_field_name='next', login_url=None)

login_required takes two arguments

1. login_url                ===>     login url path / login url name

2. redirect_field_name      ===>     where to redirect after logedin successfully. defult to 'next'


from django.contrib.auth.decorators import login_required

@login_required(login_url = 'signin-path', redirect_field_name='next')
def addbook(request):
    if request.method == 'POST':
        form  = forms.Bookform(request.POST)
        
        if form.is_bound:
            if form.is_valid():
                form.save()
            
                form = forms.Bookform()
            
                messages.success(request, 'Book added successfully')
            
    else:
        form = forms.Bookform()
        
    return render(request, 'addbook.html', {'form':form})



NOTE:
------

1. The login_required decorator does NOT check the is_active flag on a user, but the default AUTHENTICATION_BACKENDS reject inactive users.

2. If you are writing custom views for Django’s admin (or need the same authorization check that the built-in views use), you may find the 
django.contrib.admin.views.decorators.staff_member_required() decorator a useful alternative to login_required().



The LoginRequired mixin
------------------------
pass for now




How to log a user out
----------------------
logout(request)

To log out a user who has been logged in via django.contrib.auth.login(), use django.contrib.auth.logout() within your view. It takes an HttpRequest object and has no 
return value.


Ex:
----

from django.contrib.auth import logout

def signout(request):
    logout(request)
    messages.info(request, 'You have logedout successfully')
    return redirect('signin-path')


NOTE:
------
1. logout() doesn’t throw any errors if the user wasn’t logged in.

2. When you call logout(), the session data for the current request is completely cleaned out. All existing data is removed. This is to prevent another person from 
   using the same Web browser to log in and have access to the previous user’s session data.

3. If you want to put anything into the session that will be available to the user immediately after logging out, do that after calling django.contrib.auth.logout().



Limiting access to logged-in users that pass a test
----------------------------------------------------

user_passes_test(test_func, login_url=None, redirect_field_name='next')

	1. user_passes_test() takes a required argument: function name

	2. two optional arguments:

		a). login_url  ===>   Lets you specify the URL that users who don’t pass the test will be redirected to.

		b). redirect_field_name   ===>    Same as for login_required(). Setting it to None removes it from the URL, which you may want to do if you are redirecting users that don’t pass the test to a non-login page where there’s no “next page”.

Ex:
----
from django.contrib.auth.decorators import user_passes_test

@user_passes_test(email_check, login_url='/login/')
def my_view(request):
    some logic




The permission_required decorator
----------------------------------
It’s a relatively common task to check whether a user has a particular permission. 
For that reason, Django provides a shortcut for that case: the permission_required() decorator.


permission_required(perm, login_url=None, raise_exception=False)

	1. perm = required, permission code to check

	2. login_url = optional, redirects to login page if user don't have specified permission

	3. raise_exception = optional(boolean), if the raise_exception parameter is given, the decorator will raise PermissionDenied, prompting the 403 (HTTP Forbidden) view instead of redirecting to the login page.

Ex:
----
from django.contrib.auth.decorators import login_required, permission_required

@login_required(login_url = 'signin-path', redirect_field_name='next')
@permission_required('Bookstore.add_Book', login_url = 'signin-path', raise_exception = True)      # appname.permission code   ===> polls.add_choice     (permission code ===> what permission_modelname)
def addbook(request):
    if request.method == 'POST':
        form  = forms.Bookform(request.POST)
        
        if form.is_bound:
            if form.is_valid():
                form.save()
            
                form = forms.Bookform()
            
                messages.success(request, 'Book added successfully')
            
    else:
        form = forms.Bookform()
        
    return render(request, 'addbook.html', {'form':form})


This will give 403 Forbidden error if user don't have the permission








Authentication Views(auth views)
---------------------------------

Django provides some built-in Authentication Views that we can use for handling login, logout, and password management. These auth views are class based views.

These make use of the built-in auth forms(like CreateUserForm for user creation), but you can pass in your own forms as well.

These auth views provide a URL name for easier reference.


importing auth views  ===>  from django.contrib.auth import views as auth_views


List of all Auth views
------------------------

======================================================
| Auth view name	    |	  URL Name	     | 
======================================================
| LoginView                 |	  login	             |
------------------------------------------------------
| LogoutView  		    |	  logout             |
------------------------------------------------------
| PasswordResetView         |   password_reset       | 
------------------------------------------------------
| PasswordResetDoneView	    |  password_reset_done   |
------------------------------------------------------
| PasswordResetConfirmView  | password_reset_confirm |
------------------------------------------------------
| PasswordResetCompleteView | password_reset_complete|
------------------------------------------------------
| PasswordChangeView	    |   password_change      |
------------------------------------------------------
| PasswordChangeDoneView    |  password_change_done  |
------------------------------------------------------


For more detailed info about auth views and it's attributes refer this link "https://docs.djangoproject.com/en/3.0/topics/auth/default/" 
look into Authentication Views section/topic


Password Reset using PasswordResetView auth view
-------------------------------------------------

To reset the password we need four auth views

1. PasswordResetView          ===>    This view will render a template with form to give email input to which we need to send the reset link.

2. PasswordResetDoneView      ===>    This view will render a template with a email sent success message.

3. PasswordResetConfirmView   ===>    This view will render a template with form having new password and password confirmation inputs and 
				      reset my password button on clicking the link in the email sent.

4. PasswordResetCompleteView  ===>    This view will render a template with a password reset complete message.


Ex:
----
app level urls.py
------------------
 path('reset-password/', auth_views.PasswordResetView.as_view(), name = 'password_reset'),
 path('reset-password-sent/', auth_views.PasswordResetDoneView.as_view(), name = 'password_reset_done'),
 path('reset/<uidb64>/<token>/', auth_views.PasswordResetConfirmView.as_view(), name = 'password_reset_confirm'),
 path('reset-password-complete/', auth_views.PasswordResetCompleteView.as_view(), name = 'password_reset_complete'),


Next we need to do SMTP Configurations in settings.py file to send password reset email

settings.py
------------
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = 'djangoclient9@gmail.com'
EMAIL_HOST_PASSWORD = 'django@007'


NOTE:
------
All the above four password reset auth views uses default django admin templates and default forms (i.e, PasswordResetForm, SetPasswordForm).

But, we can pass our own templates and forms by using "template_name" and "form_class" attributes.

we can pass some data using "extra_context" attribute.


Custom template
----------------
path('reset-password/', auth_views.PasswordResetView.as_view(template_name = 'password_reset_email.html'), name = 'password_reset'),
path('reset-password-sent/', auth_views.PasswordResetDoneView.as_view(template_name = 'password_reset_email_sent.html'), name = 'password_reset_done'),
path('reset/<uidb64>/<token>/', auth_views.PasswordResetConfirmView.as_view(template_name = 'password_reset_confirm.html'), name = 'password_reset_confirm'),
path('reset-password-complete/', auth_views.PasswordResetCompleteView.as_view(template_name = 'password_reset_complete.html'), name = 'password_reset_complete'),


Custom form class
------------------
from Bookstore import forms

path('reset/<uidb64>/<token>/', auth_views.PasswordResetConfirmView.as_view(template_name = 'password_reset_confirm.html', form_class = forms.CustomResetPasswordFrom), name = 'password_reset_confirm'),


















